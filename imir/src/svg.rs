// SPDX-FileCopyrightText: 2025 RAprogramm <andrey.rozanov.vl@gmail.com>
//
// SPDX-License-Identifier: MIT

//! SVG optimization utilities for metrics rendering.
//!
//! This module provides post-processing capabilities for SVG files generated by
//! metrics renderers. The primary optimization ensures proper scaling and
//! display on GitHub profile pages by adding viewBox attributes and adjusting
//! dimensions.

use std::{fs, path::Path};

use regex::Regex;
use serde::Serialize;

use crate::error::{self, Error};

/// Result of SVG optimization operation.
#[derive(Debug, Clone, PartialEq, Eq, Serialize)]
pub struct SvgOptimizeResult {
    /// Path to the optimized SVG file.
    pub path:     String,
    /// Whether the SVG was modified during optimization.
    pub modified: bool
}

/// Optimizes an SVG file for proper display on GitHub.
///
/// This function processes SVG files generated by metrics renderers to ensure
/// they display correctly on GitHub profile pages. It performs the following
/// transformations:
///
/// - Adds a `viewBox` attribute matching the SVG dimensions for proper scaling
/// - Converts percentage-based width to fixed pixel width (880px for GitHub)
/// - Preserves height attribute for aspect ratio calculation
///
/// The optimization is idempotent and safe to run multiple times on the same
/// file.
///
/// # Arguments
///
/// * `path` - Path to the SVG file to optimize
///
/// # Returns
///
/// Returns [`SvgOptimizeResult`] containing the path and modification status.
///
/// # Errors
///
/// Returns [`Error::SvgIo`] when the file cannot be read or written.
///
/// # Example
///
/// ```no_run
/// use std::path::Path;
///
/// use imir::optimize_svg;
///
/// # fn main() -> Result<(), imir::Error> {
/// let result = optimize_svg(Path::new("metrics/profile.svg"))?;
/// println!("Optimized: {}", result.path);
/// println!("Modified: {}", result.modified);
/// # Ok(())
/// # }
/// ```
pub fn optimize_svg(path: &Path) -> Result<SvgOptimizeResult, Error> {
    let content = fs::read_to_string(path).map_err(|source| error::svg_io_error(path, source))?;

    let (optimized, modified) = optimize_svg_content(&content)?;

    if modified {
        fs::write(path, optimized).map_err(|source| error::svg_io_error(path, source))?;
    }

    Ok(SvgOptimizeResult {
        path: path.to_string_lossy().into_owned(),
        modified
    })
}

fn optimize_svg_content(content: &str) -> Result<(String, bool), Error> {
    let svg_tag_pattern = Regex::new(r#"(?s)<svg\s+([^>]*?)>"#).map_err(|e| Error::SvgParse {
        message: format!("failed to compile SVG tag regex: {e}")
    })?;

    let Some(captures) = svg_tag_pattern.captures(content) else {
        return Ok((content.to_owned(), false));
    };

    let attrs = &captures[1];

    let width_pattern = Regex::new(r#"width="([^"]+)""#).map_err(|e| Error::SvgParse {
        message: format!("failed to compile width regex: {e}")
    })?;

    let height_pattern = Regex::new(r#"height="([^"]+)""#).map_err(|e| Error::SvgParse {
        message: format!("failed to compile height regex: {e}")
    })?;

    let viewbox_pattern = Regex::new(r#"viewBox="([^"]+)""#).map_err(|e| Error::SvgParse {
        message: format!("failed to compile viewBox regex: {e}")
    })?;

    let width = width_pattern
        .captures(attrs)
        .and_then(|cap| cap.get(1))
        .map(|m| m.as_str());

    let height = height_pattern
        .captures(attrs)
        .and_then(|cap| cap.get(1))
        .map(|m| m.as_str());

    let has_viewbox = viewbox_pattern.is_match(attrs);

    let needs_optimization = width == Some("100%") && !has_viewbox;

    if !needs_optimization {
        return Ok((content.to_owned(), false));
    }

    let fixed_width = "880";
    let actual_height = height
        .and_then(|h| {
            if h.ends_with('%') || h.contains("auto") {
                None
            } else {
                Some(h)
            }
        })
        .unwrap_or("2048");
    let viewbox_value = format!("0 0 {fixed_width} {actual_height}");

    let mut new_attrs = attrs.to_owned();

    new_attrs = width_pattern
        .replace(&new_attrs, format!(r#"width="{fixed_width}""#))
        .into_owned();

    new_attrs = format!(r#"{new_attrs} viewBox="{viewbox_value}""#);

    let new_svg_tag = format!("<svg {new_attrs}>");
    let optimized = svg_tag_pattern.replace(content, new_svg_tag).into_owned();

    Ok((optimized, true))
}

#[cfg(test)]
mod tests {
    use std::fs;

    use tempfile::tempdir;

    use super::*;

    #[test]
    fn optimize_svg_adds_viewbox_and_fixes_width() {
        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="2048" class="columns">
  <rect width="100" height="100"/>
</svg>"#;

        let (optimized, modified) =
            optimize_svg_content(svg_content).expect("optimization failed");

        assert!(modified);
        assert!(optimized.contains(r#"width="880""#));
        assert!(optimized.contains(r#"viewBox="0 0 880 2048""#));
        assert!(optimized.contains(r#"height="2048""#));
    }

    #[test]
    fn optimize_svg_skips_when_viewbox_exists() {
        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="2048" viewBox="0 0 880 2048">
  <rect width="100" height="100"/>
</svg>"#;

        let (optimized, modified) =
            optimize_svg_content(svg_content).expect("optimization failed");

        assert!(!modified);
        assert_eq!(optimized, svg_content);
    }

    #[test]
    fn optimize_svg_skips_when_width_is_not_percentage() {
        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="880" height="2048">
  <rect width="100" height="100"/>
</svg>"#;

        let (optimized, modified) =
            optimize_svg_content(svg_content).expect("optimization failed");

        assert!(!modified);
        assert_eq!(optimized, svg_content);
    }

    #[test]
    fn optimize_svg_handles_missing_height() {
        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="100%">
  <rect width="100" height="100"/>
</svg>"#;

        let (optimized, modified) =
            optimize_svg_content(svg_content).expect("optimization failed");

        assert!(modified);
        assert!(optimized.contains(r#"width="880""#));
        assert!(optimized.contains(r#"viewBox="0 0 880 2048""#));
    }

    #[test]
    fn optimize_svg_file_writes_changes() {
        let directory = tempdir().expect("failed to create temp dir");
        let svg_path = directory.path().join("test.svg");

        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="2048">
  <rect width="100" height="100"/>
</svg>"#;

        fs::write(&svg_path, svg_content).expect("failed to write svg");

        let result = optimize_svg(&svg_path).expect("optimization failed");

        assert!(result.modified);
        assert_eq!(result.path, svg_path.to_string_lossy());

        let content = fs::read_to_string(&svg_path).expect("failed to read svg");
        assert!(content.contains(r#"width="880""#));
        assert!(content.contains(r#"viewBox="0 0 880 2048""#));
    }

    #[test]
    fn optimize_svg_file_does_not_write_when_unchanged() {
        let directory = tempdir().expect("failed to create temp dir");
        let svg_path = directory.path().join("test.svg");

        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="880" height="2048">
  <rect width="100" height="100"/>
</svg>"#;

        fs::write(&svg_path, svg_content).expect("failed to write svg");

        let content_before = fs::read_to_string(&svg_path).expect("failed to read svg");

        let result = optimize_svg(&svg_path).expect("optimization failed");

        assert!(!result.modified);

        let content_after = fs::read_to_string(&svg_path).expect("failed to read svg");
        assert_eq!(content_before, content_after);
    }

    #[test]
    fn optimize_svg_result_equality() {
        let result1 = SvgOptimizeResult {
            path:     "/tmp/test.svg".to_owned(),
            modified: true
        };
        let result2 = SvgOptimizeResult {
            path:     "/tmp/test.svg".to_owned(),
            modified: true
        };
        assert_eq!(result1, result2);
    }

    #[test]
    fn optimize_svg_result_clone() {
        let result = SvgOptimizeResult {
            path:     "/tmp/test.svg".to_owned(),
            modified: false
        };
        let cloned = result.clone();
        assert_eq!(result.path, cloned.path);
        assert_eq!(result.modified, cloned.modified);
    }

    #[test]
    fn optimize_svg_result_debug_format() {
        let result = SvgOptimizeResult {
            path:     "/tmp/debug.svg".to_owned(),
            modified: true
        };
        let debug_str = format!("{:?}", result);
        assert!(debug_str.contains("SvgOptimizeResult"));
        assert!(debug_str.contains("path"));
        assert!(debug_str.contains("modified"));
    }

    #[test]
    fn optimize_svg_propagates_io_errors() {
        let result = optimize_svg(Path::new("/nonexistent/path.svg"));
        assert!(result.is_err());
        match result {
            Err(Error::SvgIo {
                ..
            }) => {}
            other => panic!("expected SvgIo error, got {:?}", other)
        }
    }

    #[test]
    fn optimize_svg_handles_complex_attributes() {
        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Profile" width="100%" height="2048" class="columns">
  <rect width="100" height="100"/>
</svg>"#;

        let (optimized, modified) =
            optimize_svg_content(svg_content).expect("optimization failed");

        assert!(modified);
        assert!(optimized.contains(r#"width="880""#));
        assert!(optimized.contains(r#"viewBox="0 0 880 2048""#));
        assert!(optimized.contains(r#"role="img""#));
        assert!(optimized.contains(r#"aria-label="Profile""#));
    }

    #[test]
    fn optimize_svg_preserves_content() {
        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="2048">
  <defs>
    <style>/* styles */</style>
  </defs>
  <rect width="100" height="100"/>
  <text>Hello World</text>
</svg>"#;

        let (optimized, modified) =
            optimize_svg_content(svg_content).expect("optimization failed");

        assert!(modified);
        assert!(optimized.contains("<defs>"));
        assert!(optimized.contains("/* styles */"));
        assert!(optimized.contains("<rect width=\"100\" height=\"100\"/>"));
        assert!(optimized.contains("<text>Hello World</text>"));
    }

    #[test]
    fn optimize_svg_uses_actual_height_for_large_svg() {
        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="4096">
  <rect width="100" height="100"/>
</svg>"#;

        let (optimized, modified) =
            optimize_svg_content(svg_content).expect("optimization failed");

        assert!(modified);
        assert!(optimized.contains(r#"width="880""#));
        assert!(optimized.contains(r#"viewBox="0 0 880 4096""#));
        assert!(optimized.contains(r#"height="4096""#));
    }

    #[test]
    fn optimize_svg_handles_percentage_height() {
        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">
  <rect width="100" height="100"/>
</svg>"#;

        let (optimized, modified) =
            optimize_svg_content(svg_content).expect("optimization failed");

        assert!(modified);
        assert!(optimized.contains(r#"width="880""#));
        assert!(optimized.contains(r#"viewBox="0 0 880 2048""#));
    }

    #[test]
    fn optimize_svg_handles_small_height() {
        let svg_content = r#"<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="500">
  <rect width="100" height="100"/>
</svg>"#;

        let (optimized, modified) =
            optimize_svg_content(svg_content).expect("optimization failed");

        assert!(modified);
        assert!(optimized.contains(r#"width="880""#));
        assert!(optimized.contains(r#"viewBox="0 0 880 500""#));
        assert!(optimized.contains(r#"height="500""#));
    }
}
